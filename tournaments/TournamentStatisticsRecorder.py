import csv
import os
from typing import Dict, List, Optional
from game.world.factions.Faction import Faction
from game.world.units.Unit import Unit
from ai.AIPersonality import AIPersonality

class TournamentStatisticsRecorder:
    """
    Collects per-turn statistics and writes them out to CSV files.
    Currently tracks:
    - Total resources held by the faction across all provinces
    - Total income generated by the faction across all provinces
    - Count of each known unit type active for the faction
    - Number of active tiles owned by the faction
    - Number of all tiles owned by the faction including inactive provinces
    - Cumulative resources gained from tiles this game
    - Count of active provinces
    - Count of inactive provinces with tiles (so we don't count provinces eradicated/provinces with 0 tiles)
    - Decision time in milliseconds for the turn just completed
    - Number of actions taken by the AI on the turn just completed
    """

    def __init__(self, personalities: List[AIPersonality], outputDirectory: str) -> None:
        """
        Initializes a new statistics recorder.

        Args:
            personalities: A list of AI personalities participating in the tournament.
            outputDirectory: The directory where output files will be saved.
        """
        # Where to write the output files
        self.outputDirectory = outputDirectory

        # The names of the AIs being tracked, like mark1SRB, doNothing, etc.
        self.personalityNames = [personality.displayName for personality in personalities]

        # A mapping from personality name to all recorded rows for that personality
        self.rowsByPersonality: Dict[str, List[List[str]]] = {name: [] for name in self.personalityNames}

        # The CSV headers for the statistics files
        self.headers = self._buildHeaders()

        # Cumulative resources gained by each personality this game
        self.cumulativeResourceByPersonality: Dict[str, int] = {name: 0 for name in self.personalityNames}

        # We should probably ensure the directory exists rather than just trying to write files later...
        self._ensureDirectoryExists()

    def _ensureDirectoryExists(self) -> None:
        """
        Ensures that the given output directory exists, creating it if necessary.
        """
        if not os.path.isdir(self.outputDirectory):
            os.makedirs(self.outputDirectory, exist_ok=True)

    def _buildHeaders(self) -> List[str]:
        """
        Builds the CSV headers for the statistics files.

        Returns:
            A list of header strings.
        """

        baseHeaders = [
            "GameNumber",
            "TurnNumber",
            "Seed",
            "TotalResources",
            "TotalIncome"
        ]

        # Every unit is counted individually in its own column
        unitHeaders = [f"Units_{unitType}" for unitType in Unit.knownTypes]

        tailHeaders = [
            "ActiveTiles",
            "AllTiles",
            "ResourcesAccumulated",
            "ActiveProvinceCount",
            "InactiveProvinceCount",
            "DecisionTimeMillis",
            "ActionCount"
        ]

        return baseHeaders + unitHeaders + tailHeaders

    def recordInitialState(self, factions: List[Faction], gameNumber: int, seed: Optional[int]) -> None:
        """
        Records the initial state of each faction at the start of a game.
        This should be called once per faction before any turns are taken.
        Will fill in the second row of all the CSV files (the first row is headers).

        Args:
            factions: The list of factions in the game.
            gameNumber: The current game number in the tournament.
            seed: The random seed used for the game, or None if fully random.
        """

        # Even though everyone typically starts with 10 resources,
        # we say 0 here to indicate no resources have been accumulated yet.
        for name in self.personalityNames:
            self.cumulativeResourceByPersonality[name] = 0

        # Iterate through factions and record their initial stats
        for faction in factions:
            name = faction.name
            if name not in self.rowsByPersonality:
                continue

            # The turn number is 0 at the start of the game, nobody had to make decisions yet
            # so their decision time and action count are both 0 as well.
            stats = self._collectStatsForFaction(faction, 0, seed, 0.0, 0)

            # Fill in the game number so we know which game this row belongs to
            stats[0] = str(gameNumber)

            # Record the initial state for this faction
            self.rowsByPersonality[name].append(stats)

    def recordAfterTurn(
        self,
        faction: Faction,
        gameNumber: int,
        turnNumber: int,
        seed: Optional[int],
        decisionTimeMs: float,
        actionCount: int
    ) -> None:
        """
        Records the state of a faction after completing a turn.

        Args:
            faction: The faction whose state is being recorded.
            gameNumber: The current game number in the tournament.
            turnNumber: The turn number that was just completed.
            seed: The random seed used for the game, or None if fully random.
            decisionTimeMs: The time taken by the AI to make decisions this turn, in milliseconds.
            actionCount: The number of actions taken by the AI this turn.
        """
        name = faction.name

        # If somehow we don't have this personality tracked, skip it
        # so nothing crashes.
        if name not in self.rowsByPersonality:
            return
        
        stats = self._collectStatsForFaction(
            faction,
            turnNumber,
            seed,
            decisionTimeMs,
            actionCount
        )

        # Make sure we know which game this row belongs to
        stats[0] = str(gameNumber)

        # And which personality this row is for
        self.rowsByPersonality[name].append(stats)

    def _collectStatsForFaction(
        self,
        faction: Faction,
        turnNumber: int,
        seed: Optional[int],
        decisionTimeMs: float,
        actionCount: int
    ) -> List[str]:
        """
        Collects statistics for a faction at a specific turn.

        Args:
            faction: The faction to collect statistics for.
            turnNumber: The current turn number.
            seed: The random seed used for the game, or None if fully random.
            decisionTimeMs: The time taken by the AI to make decisions this turn, in milliseconds.
            actionCount: The number of actions taken by the AI this turn.

        Returns:
            A list of strings representing the collected statistics for CSV output.
        """
        
        # Total the resources and income across all provinces. Easy, we just sum them up. 
        totalResources = sum(province.resources for province in faction.provinces)
        totalIncome = sum(province.computeIncome() for province in faction.provinces)

        # Count all the active units by type
        unitCounts = self._countActiveUnits(faction)

        # Figure out how many tiles are active and how many are owned in total
        activeTiles = sum(len(province.tiles) for province in faction.provinces if province.active)
        allTiles = sum(len(province.tiles) for province in faction.provinces)

        # Update cumulative resources gained this game
        resourceGain = self._calculateTileResourceYield(faction)
        self.cumulativeResourceByPersonality[faction.name] += resourceGain

        # Figure out active and inactive province counts
        activeProvinceCount = sum(1 for province in faction.provinces if province.active)
        inactiveProvinceCount = sum(1 for province in faction.provinces if not province.active and province.tiles)

        # Build the row of statistics to return
        # These specific values correspond to the baseHeaders
        row: List[str] = [
            "0",  # Placeholder for game number, filled later if needed
            str(turnNumber),
            str(seed) if seed is not None else "random",
            str(totalResources),
            str(totalIncome)
        ]

        # Add unit counts for each known unit type
        # Corresponds to unitHeaders
        for unitType in Unit.knownTypes:
            row.append(str(unitCounts.get(unitType, 0)))

        # Finally, add the remaining stats
        # Corresponds to tailHeaders
        row.extend([
            str(activeTiles),
            str(allTiles),
            str(self.cumulativeResourceByPersonality[faction.name]),
            str(activeProvinceCount),
            str(inactiveProvinceCount),
            f"{decisionTimeMs:.3f}",
            str(actionCount)
        ])

        return row

    def _countActiveUnits(self, faction: Faction) -> Dict[str, int]:
        """
        Figures out how many active units of each type the faction has.
        Args:
            faction: The faction whose units are being counted.

        Returns:
            A dictionary mapping unit types to their respective counts.
        """

        # Set up an empty count dictionary
        counts: Dict[str, int] = {}

        # Now lets iterate through all provinces and tiles to count units
        for province in faction.provinces:
            if not province.active:
                continue

            for tile in province.tiles:
                if tile.unit is None:
                    continue
                 
                # Simply add to the count for this unit type
                # or if we can't find it yet, assume its count is 0 and add 1
                unitType = tile.unit.unitType
                counts[unitType] = counts.get(unitType, 0) + 1

        return counts

    def _calculateTileResourceYield(self, faction: Faction) -> int:
        """
        Calculates the total resource yield from all active tiles in the faction's provinces.
        Useful since it can be compared to total income to see if one faction likes to
        mostly get their income from tiles (will be indicated by this number being close to total income)
        or from farms (will be indicated by this number being much lower than total income).

        Args:
            faction: The faction whose tile resource yield is being calculated.

        Returns:
            The total resource gain from tiles this turn.
        """

        # Every tile contributes 1 resource
        # no matter what is on it.
        gain = 0
        for province in faction.provinces:
            if not province.active:
                continue
            for _ in province.tiles:
                gain += 1

        return gain

    def writeFiles(self) -> None:
        """
        Writes out all recorded statistics to CSV files in the output directory.
        """

        # Write a separate CSV file for each personality
        for name, rows in self.rowsByPersonality.items():

            # Skip personalities with no recorded rows
            if not rows:
                continue
             
            # File name is personality name with spaces replaced by underscores
            # Like for the mark1SRB personality, the file name will be mark1SRB.csv
            fileName = f"{name.replace(' ', '_')}.csv"
            path = os.path.join(self.outputDirectory, fileName)

            # Here we actually write the file with all its useful data
            with open(path, "w", newline="", encoding="utf-8") as csvFile:
                writer = csv.writer(csvFile)
                writer.writerow(self.headers)
                writer.writerows(rows)

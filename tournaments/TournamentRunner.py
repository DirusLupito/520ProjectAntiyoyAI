import datetime
import multiprocessing
import os
import time
import pdb
from typing import Dict, List, Optional, Tuple

from game.replays.Replay import Replay
from game.scenarioGenerator import generateRandomScenario
from game.world.factions.Faction import Faction
from ai.AIPersonality import AIPersonality
from tournaments.TournamentStatisticsRecorder import TournamentStatisticsRecorder
from tournaments.AITournamentConfig import AITournamentConfig
from tournaments.GameOutcome import GameOutcome


def buildFactionsForPersonalities(personalityTuples: List[Tuple[str, str]]) -> List[Faction]:
    """
    Constructs factions for the provided personalities, cycling colors as needed.
    Helper function used by both the main tournament runner and worker processes.

    Args:
        personalityTuples (List[Tuple[str, str]]): List of tuples containing (displayName, aiType) for each personality.

    Returns:
        List[Faction]: The constructed factions with assigned colors.
    """
    colorKeys = list(Faction.colorCodesMap.keys())
    factions: List[Faction] = []
    for index, (displayName, aiType) in enumerate(personalityTuples):
        # We name the faction after the personality's display name
        # so that its easier to track what AI is playing which faction
        # in replays and statistics

        color = colorKeys[index % len(colorKeys)]
        faction = Faction(name=displayName, color=color, playerType="ai", aiType=aiType)
        factions.append(faction)
    return factions


def _execute_game(
    scenario,
    factions: List[Faction],
    replay: Optional[Replay],
    gameNumber: int,
    seed: Optional[int],
    displayGames: bool,
    statisticsRecorder: Optional[TournamentStatisticsRecorder]
) -> GameOutcome:
    """
    Runs a single game and returns the resulting outcome.
    This function is used by both the main tournament runner
    and the worker processes when running games in parallel.

    Args:
        scenario: The scenario object representing the game state.
        factions (List[Faction]): The factions participating in the game.
        replay (Optional[Replay]): The replay object to record the game, if applicable.
        gameNumber (int): The index of the game being played (1-based).
        seed (Optional[int]): The seed used for the game's scenario generation.
        displayGames (bool): Whether to display each turn of the game.
        statisticsRecorder (Optional[TournamentStatisticsRecorder]): The statistics recorder, if applicable.

    Returns:
        GameOutcome: The outcome of the game, including winner and number of turns played.
    """

    gameOver = False
    turnCounter = 0

    # Similar to main.py's game loop,
    # and the logic for handling AI turns
    # with some modifications for various statistic tracking and recording features
    while not gameOver:
        activeFactions = [faction for faction in factions if any(province.active for province in faction.provinces)]

        if len(activeFactions) <= 1:
            break

        currentFaction = scenario.getFactionToPlay()

        # If somehow we got a non-AI faction, that's an error
        if currentFaction.playerType != "ai":
            raise RuntimeError("Tournament runner encountered a non-AI faction.")

        # If we are displaying games, show the current map and faction info
        # and give the user a chance to break into the debugger
        if displayGames:
            print(f"\n===== {currentFaction.name}'s Turn ({currentFaction.color}) =====")
            scenario.displayMap()
            print(f"{currentFaction.name} (AI) is thinking...")
            debugInput = input("Press Enter to continue or b to break into debugger: ")
            if debugInput.lower() == "b":
                pdb.set_trace()

        # Get the AI's actions for this turn and time how long it takes
        aiFunction = AIPersonality.implementedAIs[currentFaction.aiType]
        decisionStart = time.perf_counter()
        aiActions = aiFunction(scenario, currentFaction)
        decisionEnd = time.perf_counter()

        # Multiply by 1000 to convert seconds to milliseconds
        decisionTimeMs = (decisionEnd - decisionStart) * 1000.0

        # Apply the AI's actions to the scenario
        # appliedActions is used to both apply the actions
        # and to record them in the replay if applicable
        appliedActions: List[Tuple] = []
        if aiActions:
            if displayGames:
                print(f"{currentFaction.name} (AI) is performing {len(aiActions)} actions...")

            for action, province in aiActions:
                try:
                    scenario.applyAction(action, province)
                    appliedActions.append((action, province))
                except Exception as exc:
                    print(f"Warning: Skipping invalid action generated by {currentFaction.name}: {exc}")
        else:
            if displayGames:
                print(f"{currentFaction.name} (AI) chose to do nothing.")

        # We're done with this turn, so advance to the next turn
        # and record the turn in the replay if applicable
        turnAdvanceActions = scenario.advanceTurn()
        if replay is not None:
            turnReplayActions = list(appliedActions)
            turnReplayActions.extend(turnAdvanceActions)
            replay.recordTurn(scenario, currentFaction, turnReplayActions)

        # Keep track of how many turns have been played
        # for the final outcome reporting
        turnCounter += 1

        # If applicable, record statistics all the various statistics
        # we're interested in for this turn
        if statisticsRecorder is not None:
            statisticsRecorder.recordAfterTurn(
                currentFaction,
                gameNumber,
                turnCounter,
                seed,
                decisionTimeMs,
                len(aiActions) if aiActions else 0
            )

    # The game is over at this point, we need to figure out
    # who the winner is (if any)
    winnerFaction = None
    for faction in factions:
        if any(province.active for province in faction.provinces):
            winnerFaction = faction
            break

    # If we are displaying games, remember to show the final map and winner info
    if displayGames:
        print("\n===== Game Over =====")
        scenario.displayMap()

        if winnerFaction is not None:
            print(f"Winner: {winnerFaction.name} ({winnerFaction.color})")

    # We're all done, just need to return the outcome now
    return GameOutcome(
        winnerFaction.name if winnerFaction else None,
        winnerFaction.color if winnerFaction else None,
        seed,
        turnCounter
    )

class AITournamentRunner:
    """
    Runs tournament games according to a provided configuration.
    
    A tournament consists of multiple games played between multiple AI personalities
    over a series of rounds. This class manages the setup, execution, and recording
    of these games based on the specified configuration.
    
    General statistics about the tournament are given at the end of the run,
    and more detailed per-game per-turn statistics can be recorded if enabled.
    
    Replays of every game can also be recorded if enabled.
    
    Each turn of each game can also be optionally displayed as if it were an AI only
    game being run from main.py. This is only recommended for debugging purposes
    as it significantly slows down the tournament.
    
    For a full description of the statistics recorded, see TournamentStatisticsRecorder.
    For a full description of the seed picking modes, see TournamentSeedPicker.
    For a full description of the configuration options, see AITournamentConfig.
    """

    def __init__(self, config: AITournamentConfig) -> None:
        """
        Initializes the tournament runner with the specified configuration.
        Sets up directories for replays and statistics if those features are enabled.
        To ensure unique directories, a timestamp is used in their names.
        A tournament which ran on June 1, 2024 at 14:30:15 would have directories named
        "01-06-2024-14-30-15-tournamentReplays" and "01-06-2024-14-30-15-tournamentStats".
        
        Args:
            config (AITournamentConfig): The configuration for the tournament.
        """

        self.config = config
        self.parallelWorkerCount = config.parallelWorkerCount

        # Even though config should have already validated this,
        # we double check here to be safe
        self.displayGamesEnabled = config.displayGames and self.parallelWorkerCount == 1

        # day-month-year-hour-minute-second nomenclature for unique directory names
        dateStamp = datetime.datetime.now().strftime("%d-%m-%Y-%H-%M-%S")
        
        # Figure out the full paths for replay and statistics directories if needed
        self.replayDirectory = os.path.join(
            os.getcwd(),
            f"{dateStamp}-tournamentReplays"
        ) if config.recordReplays else None
        
        self.statisticsDirectory = os.path.join(
            os.getcwd(),
            f"{dateStamp}-tournamentStats"
        ) if config.trackStatistics else None
        
        self.statisticsRecorder: Optional[TournamentStatisticsRecorder] = None
        # If we were able to set up a statistics directory, it means we want to record stats
        if self.statisticsDirectory is not None:
            self.statisticsRecorder = TournamentStatisticsRecorder(config.personalities, self.statisticsDirectory)
            
        # If we were able to set up a replay directory, it means we want to record replays
        if self.replayDirectory is not None and not os.path.isdir(self.replayDirectory):
            os.makedirs(self.replayDirectory, exist_ok=True)

    def runTournament(self) -> None:
        """
        Handles actually running the tournament and all its games and each of those games' turns.
        Records replays and statistics as configured.
        At the end, displays a summary of the tournament results.
        """
        
        # Figure out what seeds to use for each game based on the seed picker configuration
        seeds = self.config.seedPicker.generateSeeds(self.config.roundCount)

        # Keep track of overall outcomes and wins per personality
        outcomes: List[Optional[GameOutcome]] = [None] * self.config.roundCount
        winsByPersonality: Dict[str, int] = {p.displayName: 0 for p in self.config.personalities}


        # If we aren't using parallel workers, 
        # we just use a single simple sequential loop to run each game one after another
        if self.parallelWorkerCount <= 1:
            for gameIndex in range(self.config.roundCount):

                # Get this game's seed
                seed = seeds[gameIndex]

                # Set up the factions for this game
                # with descriptive names and colors
                # so the replays are easier to follow
                factions = self._buildFactions()

                # Generate the scenario for this game
                scenario = generateRandomScenario(
                    self.config.dimension,
                    self.config.targetLandTiles,
                    factions,
                    self.config.initialProvinceSize,
                    randomSeed=seed
                )

                replay = None

                # If applicable, set up the replay for this game
                if self.config.recordReplays:
                    metadata = {
                        "dimension": self.config.dimension,
                        "targetLandTiles": self.config.targetLandTiles,
                        "initialProvinceSize": self.config.initialProvinceSize,
                        "seed": seed,
                        "factions": [
                            {
                                "name": faction.name,
                                "color": faction.color,
                                "aiType": faction.aiType
                            }
                            for faction in factions
                        ]
                    }
                    replay = Replay.fromScenario(scenario, metadata=metadata)

                # If applicable, record the initial state for statistics
                if self.statisticsRecorder is not None:
                    self.statisticsRecorder.recordInitialState(factions, gameIndex + 1, seed)

                # Run the actual game
                outcome = self._runSingleGame(
                    scenario,
                    factions,
                    replay,
                    gameIndex + 1,
                    seed,
                    self.statisticsRecorder,
                    self.displayGamesEnabled
                )

                # Track the outcome and record replay/statistics if applicable
                # Rather than appending to the outcomes list, we set by index
                # to ensure the order is correct despite possible parallel execution
                outcomes[gameIndex] = outcome

                # Track the outcome and record replay/statistics if applicable
                if outcome.winnerName is not None:
                    winsByPersonality[outcome.winnerName] += 1

                if self.config.recordReplays and replay is not None and self.replayDirectory is not None:
                    # In order to save memory and in case a crash happens later,
                    # write out the replay to disk immediately after the game
                    # rather than waiting until the end of the tournament
                    fileName = f"game{gameIndex + 1}.ayrf"
                    replayPath = os.path.join(self.replayDirectory, fileName)
                    replay.saveToFile(replayPath)

        # Otherwise, if we have more than one parallel worker,
        # we need to set up tasks for each game and run them in parallel
        # to take advantage of multiple CPU cores
        else:

            # Warn the user if they somehow have displayGames enabled at this point
            if self.config.displayGames and not self.displayGamesEnabled:
                print("Display of games has been disabled because parallel workers are enabled.")

            # Prepare the configuration that each worker will need
            # to keep track of all the info we had to have to run the
            # sequential version of the tournament above
            workerConfig = {
                "dimension": self.config.dimension,
                "targetLandTiles": self.config.targetLandTiles,
                "initialProvinceSize": self.config.initialProvinceSize,
                "recordReplays": self.config.recordReplays,
                "replayDirectory": self.replayDirectory,
                "trackStatistics": self.config.trackStatistics,
                "statisticsDirectory": self.statisticsDirectory,
                "personalities": [(personality.displayName, personality.aiType) for personality in self.config.personalities]
            }

            # Build the list of tasks for each game
            # These will be distributed to the worker processes
            # The way tasks are used is that each task is a dictionary
            # containing the game index, seed, and the shared config
            # that all workers will use.
            # A worker will receive a task, set up the factions and scenario,
            # and then run the game and return the outcome along with any statistics rows
            # that need to be recorded. The main process will then collect those results
            # and update the overall outcomes and statistics recorder as needed.
            # That same worker will then move on to the next task it is given
            # until all tasks are complete.
            # That said, the exact implementation details of how tasks are distributed
            # and managed is handled by the multiprocessing library, not by any custom code here.
            tasks = [
                {
                    "gameIndex": gameIndex,
                    "seed": seeds[gameIndex],
                    "config": workerConfig
                }
                for gameIndex in range(self.config.roundCount)
            ]

            # Use spawn context to ensure each worker process starts with a clean state.
            # This is apparently important because the default fork context (on Unix) can cause issues
            # with copying complex game state. Spawn creates entirely new Python processes,
            # avoiding potential deadlocks or corruption from inherited locks/state.
            # We use Pool to manage a fixed number of worker processes that each pull tasks
            # from the queue, execute them, and return results.
            # imap_unordered is chosen over map because it returns results as soon as they're ready
            # (not waiting for all games to finish), allowing us to process outcomes incrementally
            # and provide progress feedback. The unordered nature is fine since we store outcomes
            # by gameIndex rather than relying on result order.
            context = multiprocessing.get_context("spawn")
            with context.Pool(processes=self.parallelWorkerCount) as pool:
                for gameIndex, outcome, statsRows in pool.imap_unordered(runGameTaskWorker, tasks):
                    outcomes[gameIndex] = outcome
                    if outcome.winnerName is not None:
                        winsByPersonality[outcome.winnerName] += 1
                    if self.statisticsRecorder is not None and statsRows is not None:
                        self.statisticsRecorder.appendRows(statsRows)

        if self.statisticsRecorder is not None:
            # Write out all the statistics files now that the tournament is complete
            self.statisticsRecorder.writeFiles()

        # Since we aren't appending to outcomes but rather setting by index,
        # we need to check that all games were completed successfully
        # Will give a more descriptive error than just saying some entry in the outcomes list is None
        # during a call to _displaySummary
        missingOutcome = next((index for index, outcome in enumerate(outcomes) if outcome is None), None)
        if missingOutcome is not None:
            raise RuntimeError(f"Tournament did not complete game index {missingOutcome}.")

        orderedOutcomes: List[GameOutcome] = [outcome for outcome in outcomes if outcome is not None]

        # Display the overall tournament summary
        self._displaySummary(orderedOutcomes, winsByPersonality)

    def _buildFactions(self) -> List[Faction]:
        """
        Build the factions for the tournament based on the configured factions.
        Each faction is assigned a unique color from the available color codes.
        We want to try to ensure that no two factions have the same color,
        although if there are more factions than colors, colors will be reused.
        
        See Faction.colorCodesMap for the available colors and the ordering of those colors.
        
        Returns:
            List[Faction]: The list of factions for the tournament.
        """
        
        # Starting with an empty list of factions,
        # we iterate through each personality in the configuration
        # and create a tuple of (displayName, aiType) for each one
        personalityTuples = [
            (personality.displayName, personality.aiType)
            for personality in self.config.personalities
        ]

        # We have a helper for turning those tuples into actual factions with colors assigned
        # so let's just use that here
        return buildFactionsForPersonalities(personalityTuples)

    def _runSingleGame(
        self,
        scenario,
        factions: List[Faction],
        replay: Optional[Replay],
        gameNumber: int,
        seed: Optional[int],
        statisticsRecorder: Optional[TournamentStatisticsRecorder],
        displayGames: bool
    ) -> GameOutcome:
        """
        Runs a single tournament game and returns its outcome.
        We delegate to the shared _execute_game function
        which is used by both the main tournament runner
        and the worker processes when running games in parallel.

        Args:
            scenario: The scenario object representing the game state.
            factions (List[Faction]): The factions participating in the game.
            replay (Optional[Replay]): The replay object to record the game, if applicable.
            gameNumber (int): The index of the game being played (1-based).
            seed (Optional[int]): The seed used for the game's scenario generation.
            statisticsRecorder (Optional[TournamentStatisticsRecorder]): The statistics recorder, if applicable.
            displayGames (bool): Whether to display each turn of the game.

        Returns:
            GameOutcome: The outcome of the game, including winner and number of turns played.
        """

        return _execute_game(
            scenario,
            factions,
            replay,
            gameNumber,
            seed,
            displayGames,
            statisticsRecorder
        )

    def _displaySummary(
        self,
        outcomes: List[GameOutcome],
        winsByPersonality: Dict[str, int]
    ) -> None:
        """
        Displays a summary of the tournament results.
        This will be printed to the console no matter what,
        even if replays and statistics recording were disabled.
        
        We display each game's winner, seed, and total number of turns played,
        a description of the tournament configuration,
        and the overall win percentages for each personality.

        Args:   
            outcomes (List[GameOutcome]): The list of outcomes for each game in the tournament.
            winsByPersonality (Dict[str, int]): A mapping of personality display names to their total wins.
        """
        
        # We first iterate through each game's outcome and print its details
        # since if there are a lot of games and we printed the rest of the summary first,
        # the user would have to scroll back up to see the overall results and configuration details
        # This way, the few lines dedicated to the summary are at the end of the output, making them easier to find
        totalGames = len(outcomes)
        for index, outcome in enumerate(outcomes):
            seed = outcome.seed if outcome.seed is not None else "random"
            if outcome.winnerName is None:
                print(f"Game {index + 1} Winner: None, seed {seed}, {outcome.numberOfTurns} total turns played.")
            else:
                print(f"Game {index + 1} Winner: {outcome.winnerName} ({outcome.winnerColor}), seed {seed}, {outcome.numberOfTurns} total turns played.")

        # A description of the tournament configuration
        description = (
            f"Game played on {self.config.dimension}x{self.config.dimension} grid with "
            f"{self.config.targetLandTiles} land tiles, {len(self.config.personalities)} factions, "
            f"initial province size of {self.config.initialProvinceSize}, and {self.config.seedPicker.describe()}."
        )
        
        # Here we give the overall results for each AI personality, 
        # telling how effective each one was in the tournament
        # and what their name and faction color were if the user wants to look them up in replays or statistics
        print("\nOverall results:")
        print(description)
        for index, personality in enumerate(self.config.personalities):
            color = list(Faction.colorCodesMap.keys())[index % len(list(Faction.colorCodesMap.keys()))]
            print(f"Faction slot {index + 1} was played by the {personality.displayName}, faction color {color}.")
            
        for personality in self.config.personalities:
            wins = winsByPersonality[personality.displayName]
            percentage = (wins / totalGames) * 100 if totalGames > 0 else 0.0
            print(f"{personality.displayName} won {percentage:.1f}% of the time")


def runGameTaskWorker(task: Dict[str, object]) -> Tuple[int, GameOutcome, Optional[Dict[str, List[List[str]]]]]:
    """
    Executes a tournament game inside a worker process.
    This function is intended to be called by worker processes
    when running games in parallel as part of a tournament.
    It is otherwise unreferenced.

    Args:
        task (Dict[str, object]): A dictionary containing the game index, seed, and configuration.

    Returns:
        Tuple[int, GameOutcome, Optional[Dict[str, List[List[str]]]]]: A tuple containing the game index, the game outcome, and optional statistics rows.
    """

    # We're a worker, let's figure out our job
    # What's the game index of the game we're running?
    gameIndex = int(task["gameIndex"])

    # What's the seed for this game? If we're using a fixed or sequential or pool of seeds,
    # we need to be able to respect that rather than just picking a random seed as if the 
    # seed picker were random
    seed = task["seed"]

    # We'll figure out the rest of the scenario's details from the config
    config = task["config"]

    # Set up the factions for this game
    # with descriptive names and colors
    personalityTuples: List[Tuple[str, str]] = list(config["personalities"])
    factions = buildFactionsForPersonalities(personalityTuples)

    # We have everything we need, let's generate the scenario for this game
    scenario = generateRandomScenario(
        config["dimension"],
        config["targetLandTiles"],
        factions,
        config["initialProvinceSize"],
        randomSeed=seed
    )

    # If applicable, set up the replay for this game as well
    replay: Optional[Replay] = None
    if config["recordReplays"]:
        metadata = {
            "dimension": config["dimension"],
            "targetLandTiles": config["targetLandTiles"],
            "initialProvinceSize": config["initialProvinceSize"],
            "seed": seed,
            "factions": [
                {
                    "name": faction.name,
                    "color": faction.color,
                    "aiType": faction.aiType
                }
                for faction in factions
            ]
        }
        replay = Replay.fromScenario(scenario, metadata=metadata)

    # If applicable, set up the statistics recorder for this game as well
    statsRecorder: Optional[TournamentStatisticsRecorder] = None
    statsRows: Optional[Dict[str, List[List[str]]]] = None
    if config["trackStatistics"] and config["statisticsDirectory"] is not None:
        personalities = [AIPersonality(name, aiType) for name, aiType in personalityTuples]
        statsRecorder = TournamentStatisticsRecorder(personalities, config["statisticsDirectory"])
        statsRecorder.recordInitialState(factions, gameIndex + 1, seed)

    # Now we can delegate to the shared game execution function
    # _execute_game which handles the actual game loop
    # as this must be done sequentially for each game
    # (while the overall tournament can be parallelized,
    # individual games are basically atomic units that must be run from start to finish
    # sequentially).
    outcome = _execute_game(
        scenario,
        factions,
        replay,
        # Remember that gameIndex is 0-based but gameNumber is 1-based
        gameIndex + 1,
        seed,
        False,
        statsRecorder
    )

    # If applicable, save the replay to disk now that the game is complete
    if config["recordReplays"] and replay is not None and config["replayDirectory"] is not None:
        fileName = f"game{gameIndex + 1}.ayrf"
        replayPath = os.path.join(config["replayDirectory"], fileName)
        replay.saveToFile(replayPath)

    # If applicable, export the statistics rows for this game
    if statsRecorder is not None:
        statsRows = statsRecorder.exportRows()

    # This worker is now done, return the outcome and any statistics rows
    return gameIndex, outcome, statsRows
